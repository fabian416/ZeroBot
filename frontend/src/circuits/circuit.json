{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"5090611916251846598","abi":{"parameters":[{"name":"name","type":{"kind":"field"},"visibility":"private"},{"name":"last_name","type":{"kind":"field"},"visibility":"private"},{"name":"document_type","type":{"kind":"field"},"visibility":"private"},{"name":"document_number","type":{"kind":"field"},"visibility":"private"},{"name":"expected_hash","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"tZnBbts4FEX/xess9O57pKj+ymBQuKlbBDCcwE0KDIr++4gij5MsJKQ2ujFpPvHiyOKhZPvX7uvhy8v3zw+nb48/dp/++bX7cn44Hh++fz4+3u+fHx5P8+iv33c73n5+Ph8O89DuTX2e9bQ/H07Pu0+nl+Pxbvdzf3xZDvrxtD8t7fP+PFeHu93h9HVu58BvD8dD7f2+e509rE+Vxj7ZB7tMT+/n2/p8U0QPMOU3CeldgtYTslsPyLm8zo93832DYHJOwaY8vibkjyZokHqCBo+1hLSeEGn0njB3y1UJ00RCHvI1CdnyJUHlqs9hvHwO83W9JsHSa8K4eha2sSA9B6fhef1ybkf4RyI2z2NiTUnDtArhNy+J7YgPrYnNiNsXhXy6fBSTXZPghuHySKunUW5fFOWvLopIl/OIvHo5tLFbjjayW45WXrdrKx+P0GWzGuWrEZvnUViZSnHVJ5HSRY9UdE1CLlwNjeFXJVz8ujahWCKhvLkYf5Iw+G0Jbq+r0mLdz+HmjWY74kMbzWbEzRuNz3dvPgpdtajcjSch9/X7uKebN5rtiFs3GveULuexkVBuXxTl9kVR/uqi8MKe6zGs3jtCN1/S7YgPXdLNR5JCQJnePWb/O7/b3z+c330x2A3z7n63s92neZqWV19GYumn5TUvI+PSL8vr1GYNyxtrs22ePsObtyZak1qTWzO2eS3EpmVQDUGdoaWoUahhqKWogaiRqLTBxuKNxW0Z9JbijcUbi7cUbyzeWLyxeGOJxhKNJVpK9E+ksURLicYSjSUaSzSW1FjSnGLzXTipt97b6G3qbe7tnFVvFGkOq8s5TW08D208WxvPPS97H48+3vNy7uNjHy99fGrj49DGR6tPWnOr3npvo7ept7m3Y29Lfb6a26neleclMbTx0vOKWr14r/e80vNK7vWx10sfn1o7Da0+WatPnW/qfFP0eur1zjd1vqnzTZ3Phg5og9HpiDY4xwSlRCdzzMgxhVInNeuoZp3VTJScTnBM4phMaaRTOAZmwSyYBbNgFsyCWTALZsEsmB1mh9lhdpgdZofZYXaYHWaHOWAOmAPmgDlgDpgD5oA5YA6YE8wJ5gRzgjnBnGBOMCeYE8wJ5gxzhjnDnGHOMGeYM8wZ5gxzhnmEeYQZ0QzTbIR5hBnZDNsM3QzfDOEM4wzlDOcM6QzrDO0M7wzxDPMM9Qz3DPkM+wz9DP8MAQ0DDQUNB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHBQOCgcFA4KB4WDwkHhoHDQcdBx0HHQcdBx0HHQcdBx0HHQcdBx0HHQcdBx0HHQcdCrg/U3Wa8O+nJMqU/itTP1UnVwKVUHl1J1sJWcUlBKlDKlkVKhNPVSdXApVQeXkpNcHWydoEOyw+wwO8wOc8AcMAfJAXPAHCQHzAFzwBwwJ5gTzInkBHOCOZGcYE4wJ5gTzBnmDHMmOcOcYc4kZ5gzzBnmDPMIc3Ww/sTn1cHWcTpBJ9HJdObkGGpnTo6aXB1cStXBpVQdXEqF5OpgKwUlkquDrTRSKpSmXqoOLqXq4PJL4s/9+WH/5Xjo/6Z8ezndv/lz5fm/Jyr8/fJ0frw/fH05H+r3raU2fwP7Hw==","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use poseidon::poseidon;\n\nfn main(\n    name: Field,\n    last_name: Field,\n    document_type: Field,\n    document_number: Field,\n    expected_hash: pub Field\n) {\n    // Calculamos el hash como en el contrato Aztec\n    let hash = poseidon::bn254::hash_4([name, last_name, document_type, document_number]);\n\n    // Verificamos que coincida con el hash guardado\n    assert(hash == expected_hash);\n}\n","path":"/home/s1x3l4/Desktop/noir-hack/ZeroBot/circuit/src/main.nr"},"54":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/home/s1x3l4/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"55":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/home/s1x3l4/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"56":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/home/s1x3l4/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"names":["main"],"brillig_names":[]}